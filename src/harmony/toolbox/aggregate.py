
from math import ceil
from tabulate import tabulate

import re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from itertools import chain
from .constants import *

from .utils import s3_download, s3_list

def _agg_cdr3(x):
    """ Aggregates cdr3s, separating by semi-colon """
    if len(x)==1:
        return x + ';'
    else:
        cdr3 = ''
        for i in sorted(x):
            if i!='None':
                cdr3 += i
                cdr3 +=';'
        return cdr3


def _label_clonotype(filename, clonotype):
    """ labels control cells by clonotypes """
    controls_clonotypes_dict = CLONOTYPE_REF_HPV_CMV
    try:
        label = controls_clonotypes_dict[clonotype]
    except KeyError:
        alphas, betas = clonotype.split('__')
        alpha_list = alphas.split(';')
        beta_list = betas.split(';')
        if (CHAIN_REF_HPV['alpha'] in alpha_list) & (len(alpha_list)>2):
            label = 'Astarte_HPV_Multiplet'
        elif (CHAIN_REF_HPV['beta'] in beta_list) & (len(beta_list)>2):
            label = 'Astarte_HPV_Multiplet'
        elif (CHAIN_REF_CMV['alpha1'] in alpha_list) or (CHAIN_REF_CMV['alpha2'] in alpha_list) & (len(alpha_list)>2):
            label = 'Astarte_CMV_Multiplet'
        elif (CHAIN_REF_CMV['beta'] in beta_list) & (len(beta_list)>2):
            label = 'Astarte_CMV_Multiplet'
        else:
            label = clonotype
    return label


def load_df(path):
    df = pd.read_csv(path)
    df.barcode = df.barcode.map(lambda x: x.split('-')[0])
    df.productive = df.productive.replace({True: 'True', False: 'False'})
    
    return df


def contigs_to_clonotypes(contigs, sample):
    df = contigs.copy()
    
    betas = (df[(df.c_gene.isin(['TRBC1', 'TRBC2']))&(df.productive.replace({True: 'True', False: 'False'})=='True')][['cdr3', 'barcode']]
             .groupby('barcode')
             .agg(_agg_cdr3)
             .reset_index()
             .rename(columns={'cdr3': 'beta_cdr3'}))
    
    alphas = (df[(df.c_gene.isin(['TRAC']))&(df.productive.replace({True: 'True', False: 'False'})=='True')][['cdr3', 'barcode']]
              .groupby('barcode')
              .agg(_agg_cdr3)
              .reset_index()
              .rename(columns={'cdr3': 'alpha_cdr3'}))
    
    clonotypes = pd.merge(alphas, betas, on='barcode', how='inner')
    clonotypes['clonotype'] = clonotypes['alpha_cdr3'] + '__' + clonotypes['beta_cdr3']
    clonotypes['clonotype_label'] = clonotypes['clonotype'].apply(lambda x: _label_clonotype(sample, x))
    
    clonotypes = (pd.DataFrame(clonotypes.groupby('clonotype_label')['clonotype'].count())
                    .reset_index()
                    .rename(columns={'clonotype': 'clonotype_count'}))
    clonotypes.clonotype_count = clonotypes.clonotype_count + np.random.random(clonotypes.shape[0])
    clonotypes = (clonotypes.set_index('clonotype_label')
                            .reset_index()
                            .sort_values(by='clonotype_count', ascending=False))
                  
    return clonotypes

def extract_alphas(df):
    return df[(df.c_gene.isin(['TRAC']))&(df.productive.replace({True: 'True', False: 'False'})=='True')]

def extract_betas(df):
    return df[(df.c_gene.isin(['TRBC1', 'TRBC2']))&(df.productive.replace({True: 'True', False: 'False'})=='True')]

def load_df_clonotypes(path):
    """Loads a dataframe containing the clonotypes generated by Cell Ranger.
    Each line will be parsed so that the CDR3s for amino acid and nucleotide
    sequences have each sequence sorted alphabetically and order with the
    TRAs first and TRBs second.
    """
    def tras(x):
        return ';'.join(sorted([y.split(':')[1] for y in x.split(';') if y.startswith('TRA:')]))
    
    def trbs(x):
        return ';'.join(sorted([y.split(':')[1] for y in x.split(';') if y.startswith('TRB:')]))
    
    df = pd.read_csv(path)
    df.cdr3s_aa = df.cdr3s_aa.map(lambda x: f"TRA:{tras(x)}__TRB:{trbs(x)}" )
    df.cdr3s_nt = df.cdr3s_nt.map(lambda x: f"TRA:{tras(x)}__TRB:{trbs(x)}" )
    
    return df.groupby('cdr3s_aa').sum().reset_index()


def similar(a, b):
    """Compares two clonotypes, a and b, and considers whether
    they are similar or not. Similarity here is defined as having
    the same number of alpha and beta sequences, and that each pair
    is either equal to each other or one is a lengthening of the
    other.
    """
    tra, trb = a.split('__')
    a_tra = [x for x in sorted(tra.split(':')[1].split(';')) if x]
    a_trb = [x for x in sorted(trb.split(':')[1].split(';')) if x]
    
    tra, trb = b.split('__')
    b_tra = [x for x in sorted(tra.split(':')[1].split(';')) if x]
    b_trb = [x for x in sorted(trb.split(':')[1].split(';')) if x]
    
    if len(a_tra) != len(b_tra):
        return False
    
    if len(a_trb) != len(b_trb):
        return False
    
    for x, y in zip(sorted(a_tra), sorted(b_tra)):
        if not ((x == y) or y.startswith(x) or x.startswith(y)):
            return False
    
    for x, y in zip(sorted(a_trb), sorted(b_trb)):
        if not ((x == y) or y.startswith(x) or x.startswith(y)):
            return False
    
    return True


def find_similarities(a, b):
    return [
        (clonotype, similarities)
        for clonotype, similarities
        in [(clonotype, [x for x in b if similar(clonotype, x)])
            for clonotype in a.difference(b)]
        if len(similarities) > 0
    ]

def remove_unpaired(df):
    df['split_count'] = df['cdr3s_aa'].str.split(';').apply(len)
    df_filter1 =  df[df['split_count'] == 2 ]
    
    df_paired = df_filter1[(df_filter1['cdr3s_aa'].str.count('TRA')==1) & (df_filter1['cdr3s_aa'].str.count('TRB')==1) ]
    return df_paired

def calculate_jaccard_similarity(set1, set2):
    intersection_count = len(set1.intersection(set2))
    union_count = len(set1.union(set2))
    jaccard_similarity = intersection_count / union_count

    return jaccard_similarity


def make_clonotypes_from_tcr(df):
    
    df['clonotype'] = df['tra_cdr3']+';'+df['trb_cdr3'] 

    return df
